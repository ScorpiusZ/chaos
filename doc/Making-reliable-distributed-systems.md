##Making Reliable Distributed Systems

##Erlang 简介
>
Erlang 属于一种纯消息传递语言——即一种基于独立性很强的并行进程的语言，我们的  
编程模型广泛使用了速错（fail-fast）进程。这项技术在构建可容错系统的硬件   
平台中被普遍使用，但是在软件设计方面却用得不多。这主要是因为传统的编程  
语言并不允许不同的软件模块以彼此互不干扰的方式存在。当前普遍使用的是多  
线程的编程模型，该模型中资源是共享的，这样就造成了线程很难真正隔离起来，  
就可能导致一个线程中的错误会传播到另一个线程中，这就破坏了系统内部的坚  
固性。  
>

Erlang 是一门“面 向并发编程”（Concurrency Oriented Programming， COP）
>
在面向并发编程中，程序的并发结构应该遵循应用本身的并发结构。这种编
程风格特别适用于编写那些对现实世界建模或与现实世界进行交互的应用程序。
面向并发编程同样也具有面向对象编程的两个主要优点。即多态
（polymorphism）以及使用预先定义的协议使得不同进程类型的实例之间可以具
有相同的消息传递接口。
当我们把一个问题分解成许多并发进程的时候，我们可以让所有的进程响应
同一种消息（即多态），并且可以让所有的进程都遵循相同的消息传递接口。
并发一词是指同时发生的活动集合。现实世界就是并发的，是由无数同时发
生的活动组成的。在微观上看，我们自己的身体就是由同时运动着的原子、分子
组成的。从宏观上看，整个宇宙也是由同时运动着的星系组成的。
在现实世界中，顺序化的（sequential）活动非常罕见。当我们走在大街上的
时候，如果只看到一件事情发生的话我们一定会感到不可思议，我们期望碰到许
多同时进行的活动。
如果我们不能对同时发生的众多事件所造成的结果进行分析和预测的话，那
么我们将会面临巨大的危险，像开车这类的任务我们就不可能完成了。事实上我
们是可以做那些需要处理大量并发信息的事情的，这也表明我们本来就是具有很
多感知机制的，正是这些机制让我们能够本能地理解并发，而无需有意识地思考。
然而对于计算机编程来说，情况却突然变得相反。把活动安排成一个顺序发
生的事件链被视为是一种规范，并认为在某种意义上讲这样更简单，而把程序安
排成一组并发活动则是要尽可能避免的，并常常认为会困难一些。
我相信这是由于几乎所有传统的编程语言对真正的并发缺乏有力支持造成
的。绝大多数的编程语言本质上都是顺序化的；在这些编程语言中所有的并发性
都仅仅由底层操作系统来提供，而不是由编程语言来提供。
在本论文中，我展现了这样的一个世界，其中并发是由编程语言来提供的，
而不是由底层操作系统来提供。我把对并发提供良好支持的语言称为面向并发的
>

##COPL
### COPL 的特征
1.  COPL 应当支持进程。每一个进程应该可以看作是一个自包含的虚拟机
器（self-contained virtual machine）。
2.  运行在同一机器上的各个进程应该被高度隔离。一个进程中的故障不能
对其他进程产生副作用，除非这种交互在程序中被明确化。
3.  每个进程必须用一个唯一的、不可仿造的标识符来标识。我们称之为进
程的 Pid。
4.  进程之间没有共享状态。进程只通过消息传递来进行交互。只要知道进
程的 Pid，就可以向它发消息。
5. 消息传递被认为是不可靠的，无传输保障的。
6.  一个进程应当可以检测另一个进程中的故障，并可以知道发生故障的原
因。

值得注意的是，COPL 提供的并发性一定是真正的并发性，因此以进程的形
式存在的对象都是真正并发的，进程间的消息传递也是真正的异步消息，而不像
许多面向对象语言中一样是通过远程过程调用（remote procedure call）来冒充。
还应当注意，故障的原因并不总是正确的。例如，在一个分布式系统中，我
们可能收到进程已经死亡的通知消息，然而事实上是发生了一个网络错误。

### 进程隔离
对 理 解 COP 和创建可容错软件来说，一个核心的概念就是 进程隔离
（isolation）
，同一台计算机上运行的两个进程，应当如同分别独立运行在物理上
分离的两台计算机上一样。
理想的架构当然是面向并发的程序的每一个进程都给分配一个专用的处理
器。但是在理想成为现实之前，我们不得不面对的事实是多个进程要运行在同一
台计算机上。然而我们仍然应当认为所有的进程都运行在物理上独立的计算机
上。
进程隔离有着许多好处：

##怎么构建可容错的系统
>我们怎么才能够构建出在软件存在错误的时候具有合理行为的可容错的软 
件系统呢？这是本论文余下部分要回答的问题。我先给出一个简洁的答案，在本  
文的剩余部分会对其进行细化。  
为了构建出在软件存在错误的时候仍具有合理行为的可容错软件系统，我们  
>


* 通常要求在 40 年里停机时间不超过 2 小时


* 我们将软件组织成一个系统要完成的任务的层次结构，每一个任务对应
于一组目标，具有给定任务的软件必须尝试去完成和该任务相关的目
标。
所有任务按照复杂性排序。最顶层的任务最复杂。如果最顶层任务
完的目标都被完成，那么整个系统就运转正常。较低层次的任务应当能
够保持系统以一种可接受的方式运转，即使系统所提供的服务有所折
扣。 
系统中低层任务较高层任务更容易完成其目标。


* 我们将尽力完成顶层的任务。


* 当在完成某一目标的过程中检测到了一个错误，我们将尝试纠正这个错
误。当我们不能够纠正该错误的时候，我们将立即取消当前的任务而启
动一个更简单一些的任务。


>
编写这样一个任务层次需要一套强有力的封装方法。我们需要强有力的封装
方法来隔离错误。我们不想再去编写那种系统中的一个部分发生的错误会对其他
部分产生不利影响的系统。
我们需要以一种能够检测到在试图完成目标时所发生的所有错误的方式，来
隔离为了完成某一目标而编写的所有代码。并且，当我们在试图同时完成多个目
标时，我们不希望系统中某个部分所发发生的错误，会传播到系统的另外一个部
分中。
因此，在构建可容错软件系统的过程中要解决的本质问题就是故障隔离。不
同的程序员会编写不同的模块，有的模块正确，有的存在错误。我们不希望有错
误的模块对没有错误的模块产生任何不利的影响。
为了提供这种故障隔离机制，我们采用了传统操作系统中进程的概念。进程
提供了保护区域，一个进程出错，不会影响到其他进程的运行。不同程序员编写
的不同应用程序分别跑在不同的进程中；一个应用程序的错误不会对系统中运行
的其他应用程序产生副作用。
这种选择当然满足了初步的要求。然而因为所有进程使用同一片 CPU、同
一块物理内存，所以当不同进程争抢 CPU 资源或者使用大量内存的时候，还是
可能对系统中的其他进程产生负面影响。进程间的相互冲突程度取决于操作系统
的设计特性。
在我们的系统中，进程和并发编程是语言的一部分，而不是由宿主操作系统
提供的。这样做比直接采用操作系统进程拥有很多优势：
>

*并发程序可以一致地运行在不同的操作系统上——不同的特定操作系
中是如何实现进程的不会对我们造成限制。我们的程序运行在不同的操
作系统和处理器上唯一可见的差异就是 CPU 的处理速度和内存的大小。
所有的同步问题和进程间通信都应当跟宿主的操作系统的特性没有一
点关系。

* 我们这种基于语言的进程比传统的操作系统进程要轻量得多。在我们的
语言里，创建一个进程是非常高效的，要比大多数操作系统中进程的创
建快几个数量级[12,14]，甚至比大多数语言中线程的创建都快几个数量
级。

* 我们的系统对操作系统的要求非常少。我们只用了操作系统很小的一部
分服务，所以把我们的系统移植到譬如嵌入式系统等特定环境下是相当
简单的。

>
我们的应用程序是通过大量互相通信的并行进程构建起来的。我们采用这种
方式是因为：
>

* 它提供了一个架构基础设施——我们可以用一组相互通信的进程组织
起我们的系统。通过枚举出系统中的所有进程，并定义出进程间消息传
递的通道，我们就可以很方便地把系统划分成定义良好的子部件，并可
以对这些子部件进行单独实现和测试。这种方法学也是 SDL[45]系统设
计方法学的最高境界。

* 巨大的潜在效率——设计成以许多独立的并行进程来实现的系统，可以
很方便地实现在多处理器上，或者运行在分布式的处理器网络上。注意，
这种效率的提升只是潜在的，只有当应用程序可以被分解成许多真正独
立的任务时，才能产生实效。如果任务之间有很强的数据依赖，这种提
升往往是不可能的。

* 故障隔离——没有共享数据的并发进程提供了一种强大的故障隔离方
法。一个并发进程的软件错误不会影响到系统中其他进程的运行。

##系统需求
1. 并发性——我们的系统必须支持并发性。创建或销毁一个并发进程的计
算开销一定要非常小，即使创建大量的并发进程，也不应当带来灾难。
2. 错误封装——一个进程中发生的错误一定不能破坏系统中其他的进程。
3. 故障检测——一定要可以检测到本地异常（本地进程中发生的异常）和
远程异常（非本地进程中发生的异常）。
4. 故障识别——我们要能够识别出异常产生的原因。
5. 代码升级——要有某种机制来替换执行中的代码，而不必停下系统。
6. 持久存储——我们需要把数据按某种策略存储下来，以便恢复一个已经
崩溃的系统。

>
还有一点非常重要，即为了满足上述需求所采用的实现方式一定要高效——
如果不能够可靠地创建几十万个进程，那么并发性就没什么大用；如果故障报告
中没有包含足够的信息使得随后可以纠正故障，那么故障识别也就没有什么大
用。
上述需求的实现方式可以是多种多样。譬如并发性，既能够由语言原语来提
供（例如 Erlang 语言）
，也能够由操作系统来提供（例如 Unix）。像 C 和 Java 之
类的语言本身并不是面向并发的，但是可以利用操作系统的那些让人觉得可以达
到并发性的原语来获得并发性。确实，并发程序可以由本身并不具备并发性的语
言来编写。
>

##语言需求
1.  封装原语——语言必须有多种手段来限制错误的蔓延。应当可以把一个
进程隔离起来，免得它会破坏其他进程。
2.  并发性——语言必须提供一种轻量化的机制来创建并行进程，以及在进
程间发送消息。进程的上下文切换、消息传递必须非常高效。并行进程
还必须以一种合理的方式来分享 CPU 时间，以便当前使用 CPU 的进程不
至于垄断 CPU，而其他的进程处于“准备好”状态而得不到处理。
3.  错误检测原语——语言应当允许一个进程监控另一个进程，从而检测被
监控进程是否因任何原因而终止。
4.  位置透明——如果我们知道了一个进程的 Pid，我们就应该可以向它发
送消息，无论它是本地还是远程的。
5.  动态代码升级——应该可以动态替换运行时系统中的代码。注意，因为
许进程可能同时按照同一份代码在运行，所以我们需要一种机制，来
允许现有的进程按照“老”的代码运行，而同时“新”进程按照修改后
的代码运行。

>
上述对于编程语言的需求不仅要被满足，而且要以一种合理有效的方式被
满足。当我们编程的时候，不希望我们的表达自由受到诸如进程数目之类的限
制，我们也不希望担心当一个进程试图垄断 CPU 时会发生什么事情。
系统中进程个数的上限应该足够大，以便我们编程时不用把进程的个数作
为一个限制因素来考虑。例如，为了构建一个处理 1 万个并行用户会话的交换
系统，我们可能需要创建多达 10 万个进程 。
上述 6 条特性对于简化应用程序的编写是必要的。如果我们能够将问题的
并发结构以 1:1 的方式映射到解决该问题的应用程序的进程结构上的话，我们
把语义上一组分布式的交互部件映射到 Erlang 程序的过程就会极大地简化。
>

##错误处理

在 Erlang 里求取一个函数的值一定只有两种结果：要么函数就返回一个值，
要么它就产生一个异常。
异常可以隐式地产生（即由 Erlang 运行时系统产生），也可以通过调用 exit
（X）原语来显式地产生。隐式地产生异常将在下一节讲述。
下面是一个隐式地产生异常的一个例子，假设我们写一个函数如：
`	factorial(0) -> 1;	
    factorial(N) -> N*factorial(N-1).	
`	
求值 factorial(10)将返回一个值 3628800，但是如果求取 factorial(abc)的值，
则将产生一个异常{‘EXIT’, {badarith,…}。异常会引起程序停下正在执行的操作
转而去做其他的事情——这就是它们被称作异常的原因。如果我们写：	
`
    J = factorial(I)
`		
如果 I 是整数的话，我们期望 J 被赋上 factorial(I)的值。如果用一个非整数
的参数调用 factorial，则该语句将没有意义。下面的程序片断：	
`
I = "monday",
J = factorial(I),
`	
就是没有意义的，因为我们无法计算 factorial(“monday”)。因此 J 并没有赋
值而且赋值也没有任何意义。
许多编程语言对于有效值和异常之间的区别视而不见，即使程序已经变得毫
无意义也依然盲目地执行下去。

###Erlang 异常种类
异常是为 Erlang 运行时系统所检测到的一种非正常状态。Erlang 程序是被编
译成虚拟机指令并且由一个虚拟机仿真器来执行的。而虚拟机仿真器是 Erlang
运行时系统的一部分。
一旦仿真器检测到某种不知所措的状态，它就会产生一个异常。一共有 6
种类型的异常：

1.  值错误（value error）——就是诸如“被 0 除”之类的错误。这种情况下
传给函数的参数的类型是正确的，但是值错了。

2.  类型错误（type error）——这类错误是指调用 Erlang 的内置函数的时候
所填的参数类型不正确。例如，有一个内置函数为 atom_to_list(A)，是
将原子 A 转换成其 ASCII 码的一个整数列表。如果变量 A 并不是一个
原子，运行时系统就会产生一个异常。

3.  模式匹配错误（pattern-matching error）——这类错误是指试图将一个数
据结构与一些模式进行匹配，却找不到匹配成功的模式的错误。这种错
误会在函数头匹配时产生，或者在诸如 case，receive 或 if 语句中进行匹
配时产生。

4.  显式调用 exit（explicit exits）——这类错误是在显式调用表达式 exit(Why)
时产生的，该调用会产生一个 Why 异常。
58

5. 错误传播（error propagation）——如果一个进程收到一个 exit 信号，它
可以选择停掉自己并把该 exit 信号传播给所有它连接着的进程（见 3.5.6
节）。
6. 系统异常(system exception)——运行时系统也许会因为内存耗尽或检测
到一个内部表不一致时终结掉一个进程。这类错误不在程序员的控制范
围之内。

###已修正错误与未修正错误

假设我们写了如下程序片断：

    g(X) ->
    	case (catch h(X)) of
    		{’EXIT’, _} ->
    			10;
    		Val ->
    			Val
    	end.

    h(cat) -> exit(dog);
    h(N) -> 10*N.
1. 求值 h(cat)被求值。
2. h 产生一个异常。
3. 该异常被 g 捕获。
4. g 返回一个值。
	
当求取 g(dog)之值时，将引发下列事情：  	

1. h(dog)被求值。
2. 在 h 的函数体中，变量 N 被绑定为值 dog。
3. 求取 N=dog 时 N*10 的值。
4. 在函数‘*’（译注：进行乘法运算的函数）中产生了一个异常。
5. 该异常被传播给函数 h。
6. 该异常被函数 g 捕获。
7. g 返回一个值。
如果我们仔细观察上面的过程我们就可以发现：在求值 h(dog)中产生了一个
异常，而该异常在 g 中被捕获并被纠正了。
在此我们就可以说一个错误确实发生了，但是它被修正了。
如果我们是直接求值 h(dog)，那么将会产生异常，但是并没有被捕获和修正。

##编程技术
1.  抽象出并发——某种意义上讲，并发程序比顺序化程序要难得多。为了
避免在同一个模块里既有并发的代码又有顺序化的代码，我展示了如何
将代码组织到两个模块里，其中一个全部是并发代码，另一个则只有纯
的顺序化代码。

2.  抱持 Erlang 的世界观——在 Erlang 的世界里，万事万物都是进程。为
了 帮 助 我 们 抱 持 这 种 观 点 ， 我 介 绍 了 一 种 协 议 转 换 器 （ protocol
converter）的思想，它有助于程序员建立任何事物都是 Erlang 进程这
一观念。

3.  Erlang 的错误观——Erlang 的错误处理方式与其他语言有本质的区别。
我将展示在 Erlang 中该如何编写出错情况下的程序。

4.  显意编程——这是一种程序员能够轻易就从源代码中看出编程者的意
图的编程风格，而不是通过对代码进行表面的分析来猜测编程者的意
图。

###抽象出并发
我们编程的时候，经常期望将代码划分为“困难的”和“容易的”模块。困
难的模块要少，由专家程序员来编写；而容易的模块多，由不那么有经验的程序
员来编写。图 4.1 就显示了一个通用部件（困难的部分），和许多用来对通用部
件进行参数化的“插件”（容易的部分）。
通用部件应该对插件隐藏起并发和容错机制的细节，而那些插件则应该只用
有着良好类型定义的顺序化代码来编写。
接下来，我将要描述如何将一个客户-服务器（client-server）划分成一个通
用部件和许多插件。
将一个系统划分成通用部件和插件是一种常用的编程技术——在我们的方
式中的非常之处在于通用部件能够提供一个丰富的环境来执行插件。插件的代码
中可以包含错误，插件的代码可以动态替换，整个插件可以在网络上自由搬移，
所有的这些都不需要对插件的代码做任何额外的设计。
抽象出并发是用来划分一个大型软件系统的最有力的手段之一。运用该方法
不仅可以轻轻松松地用 Erlang 来编写并发程序，更是可以把显式地对并发进行
处理的代码约束在尽量少的模块中。
这样做的原因是，并发处理的代码一般都很难以无副作用（side-effect free）
的方式来编写，就使得并发程序比纯顺序化的、无副作用的代码更难以理解和分
析。在一个包含大量进程的系统中，消息传递顺序化问题和潜在的死锁
（dead-lock）或活锁（live-lock）问题会使得并发系统非常难以理解和编写。
用 Erlang 编写应用程序，用的最普遍的一种抽象就是客户-服务器抽象。事
实上，在用 Erlang 编写的所有应用程序中，对客户-服务器抽象的使用远远多于
对其它抽象的使用。例如，在 8.3.1 小节我们将看到，在 AXD301 系统使用的所
有 behaviour 中，gen_server 这种 behaviour 就占到了 63％，该 behaviour 提供了
一种客户-服务器抽象。
